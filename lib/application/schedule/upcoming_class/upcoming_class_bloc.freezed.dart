// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'upcoming_class_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UpcomingClassEventTearOff {
  const _$UpcomingClassEventTearOff();

  _Initialise initialise() {
    return const _Initialise();
  }

  _Reload reload() {
    return const _Reload();
  }

  _PageChanged pageChanged(int page) {
    return _PageChanged(
      page,
    );
  }

  _PageLimitChanged pageLimitChanged(int pageLimit) {
    return _PageLimitChanged(
      pageLimit,
    );
  }

  _CancelClass cancelClass(Appointment appointment) {
    return _CancelClass(
      appointment,
    );
  }

  _ClassCancellationMessageDisplayed classCancellationMessageDisplayed() {
    return const _ClassCancellationMessageDisplayed();
  }

  _AppointmentSelected appointmentSelected(Appointment appointment) {
    return _AppointmentSelected(
      appointment,
    );
  }
}

/// @nodoc
const $UpcomingClassEvent = _$UpcomingClassEventTearOff();

/// @nodoc
mixin _$UpcomingClassEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpcomingClassEventCopyWith<$Res> {
  factory $UpcomingClassEventCopyWith(
          UpcomingClassEvent value, $Res Function(UpcomingClassEvent) then) =
      _$UpcomingClassEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$UpcomingClassEventCopyWithImpl<$Res>
    implements $UpcomingClassEventCopyWith<$Res> {
  _$UpcomingClassEventCopyWithImpl(this._value, this._then);

  final UpcomingClassEvent _value;
  // ignore: unused_field
  final $Res Function(UpcomingClassEvent) _then;
}

/// @nodoc
abstract class _$InitialiseCopyWith<$Res> {
  factory _$InitialiseCopyWith(
          _Initialise value, $Res Function(_Initialise) then) =
      __$InitialiseCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialiseCopyWithImpl<$Res>
    extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$InitialiseCopyWith<$Res> {
  __$InitialiseCopyWithImpl(
      _Initialise _value, $Res Function(_Initialise) _then)
      : super(_value, (v) => _then(v as _Initialise));

  @override
  _Initialise get _value => super._value as _Initialise;
}

/// @nodoc

class _$_Initialise implements _Initialise {
  const _$_Initialise();

  @override
  String toString() {
    return 'UpcomingClassEvent.initialise()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initialise);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return initialise();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return initialise?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (initialise != null) {
      return initialise();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return initialise(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return initialise?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (initialise != null) {
      return initialise(this);
    }
    return orElse();
  }
}

abstract class _Initialise implements UpcomingClassEvent {
  const factory _Initialise() = _$_Initialise;
}

/// @nodoc
abstract class _$ReloadCopyWith<$Res> {
  factory _$ReloadCopyWith(_Reload value, $Res Function(_Reload) then) =
      __$ReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ReloadCopyWithImpl<$Res> extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$ReloadCopyWith<$Res> {
  __$ReloadCopyWithImpl(_Reload _value, $Res Function(_Reload) _then)
      : super(_value, (v) => _then(v as _Reload));

  @override
  _Reload get _value => super._value as _Reload;
}

/// @nodoc

class _$_Reload implements _Reload {
  const _$_Reload();

  @override
  String toString() {
    return 'UpcomingClassEvent.reload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Reload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return reload();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return reload?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (reload != null) {
      return reload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return reload(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return reload?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (reload != null) {
      return reload(this);
    }
    return orElse();
  }
}

abstract class _Reload implements UpcomingClassEvent {
  const factory _Reload() = _$_Reload;
}

/// @nodoc
abstract class _$PageChangedCopyWith<$Res> {
  factory _$PageChangedCopyWith(
          _PageChanged value, $Res Function(_PageChanged) then) =
      __$PageChangedCopyWithImpl<$Res>;
  $Res call({int page});
}

/// @nodoc
class __$PageChangedCopyWithImpl<$Res>
    extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$PageChangedCopyWith<$Res> {
  __$PageChangedCopyWithImpl(
      _PageChanged _value, $Res Function(_PageChanged) _then)
      : super(_value, (v) => _then(v as _PageChanged));

  @override
  _PageChanged get _value => super._value as _PageChanged;

  @override
  $Res call({
    Object? page = freezed,
  }) {
    return _then(_PageChanged(
      page == freezed
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_PageChanged implements _PageChanged {
  const _$_PageChanged(this.page);

  @override
  final int page;

  @override
  String toString() {
    return 'UpcomingClassEvent.pageChanged(page: $page)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PageChanged &&
            const DeepCollectionEquality().equals(other.page, page));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(page));

  @JsonKey(ignore: true)
  @override
  _$PageChangedCopyWith<_PageChanged> get copyWith =>
      __$PageChangedCopyWithImpl<_PageChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return pageChanged(page);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return pageChanged?.call(page);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (pageChanged != null) {
      return pageChanged(page);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return pageChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return pageChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (pageChanged != null) {
      return pageChanged(this);
    }
    return orElse();
  }
}

abstract class _PageChanged implements UpcomingClassEvent {
  const factory _PageChanged(int page) = _$_PageChanged;

  int get page;
  @JsonKey(ignore: true)
  _$PageChangedCopyWith<_PageChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PageLimitChangedCopyWith<$Res> {
  factory _$PageLimitChangedCopyWith(
          _PageLimitChanged value, $Res Function(_PageLimitChanged) then) =
      __$PageLimitChangedCopyWithImpl<$Res>;
  $Res call({int pageLimit});
}

/// @nodoc
class __$PageLimitChangedCopyWithImpl<$Res>
    extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$PageLimitChangedCopyWith<$Res> {
  __$PageLimitChangedCopyWithImpl(
      _PageLimitChanged _value, $Res Function(_PageLimitChanged) _then)
      : super(_value, (v) => _then(v as _PageLimitChanged));

  @override
  _PageLimitChanged get _value => super._value as _PageLimitChanged;

  @override
  $Res call({
    Object? pageLimit = freezed,
  }) {
    return _then(_PageLimitChanged(
      pageLimit == freezed
          ? _value.pageLimit
          : pageLimit // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_PageLimitChanged implements _PageLimitChanged {
  const _$_PageLimitChanged(this.pageLimit);

  @override
  final int pageLimit;

  @override
  String toString() {
    return 'UpcomingClassEvent.pageLimitChanged(pageLimit: $pageLimit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PageLimitChanged &&
            const DeepCollectionEquality().equals(other.pageLimit, pageLimit));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(pageLimit));

  @JsonKey(ignore: true)
  @override
  _$PageLimitChangedCopyWith<_PageLimitChanged> get copyWith =>
      __$PageLimitChangedCopyWithImpl<_PageLimitChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return pageLimitChanged(pageLimit);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return pageLimitChanged?.call(pageLimit);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (pageLimitChanged != null) {
      return pageLimitChanged(pageLimit);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return pageLimitChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return pageLimitChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (pageLimitChanged != null) {
      return pageLimitChanged(this);
    }
    return orElse();
  }
}

abstract class _PageLimitChanged implements UpcomingClassEvent {
  const factory _PageLimitChanged(int pageLimit) = _$_PageLimitChanged;

  int get pageLimit;
  @JsonKey(ignore: true)
  _$PageLimitChangedCopyWith<_PageLimitChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$CancelClassCopyWith<$Res> {
  factory _$CancelClassCopyWith(
          _CancelClass value, $Res Function(_CancelClass) then) =
      __$CancelClassCopyWithImpl<$Res>;
  $Res call({Appointment appointment});

  $AppointmentCopyWith<$Res> get appointment;
}

/// @nodoc
class __$CancelClassCopyWithImpl<$Res>
    extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$CancelClassCopyWith<$Res> {
  __$CancelClassCopyWithImpl(
      _CancelClass _value, $Res Function(_CancelClass) _then)
      : super(_value, (v) => _then(v as _CancelClass));

  @override
  _CancelClass get _value => super._value as _CancelClass;

  @override
  $Res call({
    Object? appointment = freezed,
  }) {
    return _then(_CancelClass(
      appointment == freezed
          ? _value.appointment
          : appointment // ignore: cast_nullable_to_non_nullable
              as Appointment,
    ));
  }

  @override
  $AppointmentCopyWith<$Res> get appointment {
    return $AppointmentCopyWith<$Res>(_value.appointment, (value) {
      return _then(_value.copyWith(appointment: value));
    });
  }
}

/// @nodoc

class _$_CancelClass implements _CancelClass {
  const _$_CancelClass(this.appointment);

  @override
  final Appointment appointment;

  @override
  String toString() {
    return 'UpcomingClassEvent.cancelClass(appointment: $appointment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CancelClass &&
            const DeepCollectionEquality()
                .equals(other.appointment, appointment));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(appointment));

  @JsonKey(ignore: true)
  @override
  _$CancelClassCopyWith<_CancelClass> get copyWith =>
      __$CancelClassCopyWithImpl<_CancelClass>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return cancelClass(appointment);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return cancelClass?.call(appointment);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (cancelClass != null) {
      return cancelClass(appointment);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return cancelClass(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return cancelClass?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (cancelClass != null) {
      return cancelClass(this);
    }
    return orElse();
  }
}

abstract class _CancelClass implements UpcomingClassEvent {
  const factory _CancelClass(Appointment appointment) = _$_CancelClass;

  Appointment get appointment;
  @JsonKey(ignore: true)
  _$CancelClassCopyWith<_CancelClass> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ClassCancellationMessageDisplayedCopyWith<$Res> {
  factory _$ClassCancellationMessageDisplayedCopyWith(
          _ClassCancellationMessageDisplayed value,
          $Res Function(_ClassCancellationMessageDisplayed) then) =
      __$ClassCancellationMessageDisplayedCopyWithImpl<$Res>;
}

/// @nodoc
class __$ClassCancellationMessageDisplayedCopyWithImpl<$Res>
    extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$ClassCancellationMessageDisplayedCopyWith<$Res> {
  __$ClassCancellationMessageDisplayedCopyWithImpl(
      _ClassCancellationMessageDisplayed _value,
      $Res Function(_ClassCancellationMessageDisplayed) _then)
      : super(_value, (v) => _then(v as _ClassCancellationMessageDisplayed));

  @override
  _ClassCancellationMessageDisplayed get _value =>
      super._value as _ClassCancellationMessageDisplayed;
}

/// @nodoc

class _$_ClassCancellationMessageDisplayed
    implements _ClassCancellationMessageDisplayed {
  const _$_ClassCancellationMessageDisplayed();

  @override
  String toString() {
    return 'UpcomingClassEvent.classCancellationMessageDisplayed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClassCancellationMessageDisplayed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return classCancellationMessageDisplayed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return classCancellationMessageDisplayed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (classCancellationMessageDisplayed != null) {
      return classCancellationMessageDisplayed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return classCancellationMessageDisplayed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return classCancellationMessageDisplayed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (classCancellationMessageDisplayed != null) {
      return classCancellationMessageDisplayed(this);
    }
    return orElse();
  }
}

abstract class _ClassCancellationMessageDisplayed
    implements UpcomingClassEvent {
  const factory _ClassCancellationMessageDisplayed() =
      _$_ClassCancellationMessageDisplayed;
}

/// @nodoc
abstract class _$AppointmentSelectedCopyWith<$Res> {
  factory _$AppointmentSelectedCopyWith(_AppointmentSelected value,
          $Res Function(_AppointmentSelected) then) =
      __$AppointmentSelectedCopyWithImpl<$Res>;
  $Res call({Appointment appointment});

  $AppointmentCopyWith<$Res> get appointment;
}

/// @nodoc
class __$AppointmentSelectedCopyWithImpl<$Res>
    extends _$UpcomingClassEventCopyWithImpl<$Res>
    implements _$AppointmentSelectedCopyWith<$Res> {
  __$AppointmentSelectedCopyWithImpl(
      _AppointmentSelected _value, $Res Function(_AppointmentSelected) _then)
      : super(_value, (v) => _then(v as _AppointmentSelected));

  @override
  _AppointmentSelected get _value => super._value as _AppointmentSelected;

  @override
  $Res call({
    Object? appointment = freezed,
  }) {
    return _then(_AppointmentSelected(
      appointment == freezed
          ? _value.appointment
          : appointment // ignore: cast_nullable_to_non_nullable
              as Appointment,
    ));
  }

  @override
  $AppointmentCopyWith<$Res> get appointment {
    return $AppointmentCopyWith<$Res>(_value.appointment, (value) {
      return _then(_value.copyWith(appointment: value));
    });
  }
}

/// @nodoc

class _$_AppointmentSelected implements _AppointmentSelected {
  const _$_AppointmentSelected(this.appointment);

  @override
  final Appointment appointment;

  @override
  String toString() {
    return 'UpcomingClassEvent.appointmentSelected(appointment: $appointment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AppointmentSelected &&
            const DeepCollectionEquality()
                .equals(other.appointment, appointment));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(appointment));

  @JsonKey(ignore: true)
  @override
  _$AppointmentSelectedCopyWith<_AppointmentSelected> get copyWith =>
      __$AppointmentSelectedCopyWithImpl<_AppointmentSelected>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialise,
    required TResult Function() reload,
    required TResult Function(int page) pageChanged,
    required TResult Function(int pageLimit) pageLimitChanged,
    required TResult Function(Appointment appointment) cancelClass,
    required TResult Function() classCancellationMessageDisplayed,
    required TResult Function(Appointment appointment) appointmentSelected,
  }) {
    return appointmentSelected(appointment);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
  }) {
    return appointmentSelected?.call(appointment);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialise,
    TResult Function()? reload,
    TResult Function(int page)? pageChanged,
    TResult Function(int pageLimit)? pageLimitChanged,
    TResult Function(Appointment appointment)? cancelClass,
    TResult Function()? classCancellationMessageDisplayed,
    TResult Function(Appointment appointment)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (appointmentSelected != null) {
      return appointmentSelected(appointment);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialise value) initialise,
    required TResult Function(_Reload value) reload,
    required TResult Function(_PageChanged value) pageChanged,
    required TResult Function(_PageLimitChanged value) pageLimitChanged,
    required TResult Function(_CancelClass value) cancelClass,
    required TResult Function(_ClassCancellationMessageDisplayed value)
        classCancellationMessageDisplayed,
    required TResult Function(_AppointmentSelected value) appointmentSelected,
  }) {
    return appointmentSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
  }) {
    return appointmentSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialise value)? initialise,
    TResult Function(_Reload value)? reload,
    TResult Function(_PageChanged value)? pageChanged,
    TResult Function(_PageLimitChanged value)? pageLimitChanged,
    TResult Function(_CancelClass value)? cancelClass,
    TResult Function(_ClassCancellationMessageDisplayed value)?
        classCancellationMessageDisplayed,
    TResult Function(_AppointmentSelected value)? appointmentSelected,
    required TResult orElse(),
  }) {
    if (appointmentSelected != null) {
      return appointmentSelected(this);
    }
    return orElse();
  }
}

abstract class _AppointmentSelected implements UpcomingClassEvent {
  const factory _AppointmentSelected(Appointment appointment) =
      _$_AppointmentSelected;

  Appointment get appointment;
  @JsonKey(ignore: true)
  _$AppointmentSelectedCopyWith<_AppointmentSelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ClassCancellationStatusTearOff {
  const _$ClassCancellationStatusTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _Loading loading() {
    return const _Loading();
  }

  _Succeed succeed() {
    return const _Succeed();
  }

  _Failed failed(Failure failure) {
    return _Failed(
      failure,
    );
  }
}

/// @nodoc
const $ClassCancellationStatus = _$ClassCancellationStatusTearOff();

/// @nodoc
mixin _$ClassCancellationStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() succeed,
    required TResult Function(Failure failure) failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succeed value) succeed,
    required TResult Function(_Failed value) failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClassCancellationStatusCopyWith<$Res> {
  factory $ClassCancellationStatusCopyWith(ClassCancellationStatus value,
          $Res Function(ClassCancellationStatus) then) =
      _$ClassCancellationStatusCopyWithImpl<$Res>;
}

/// @nodoc
class _$ClassCancellationStatusCopyWithImpl<$Res>
    implements $ClassCancellationStatusCopyWith<$Res> {
  _$ClassCancellationStatusCopyWithImpl(this._value, this._then);

  final ClassCancellationStatus _value;
  // ignore: unused_field
  final $Res Function(ClassCancellationStatus) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res>
    extends _$ClassCancellationStatusCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'ClassCancellationStatus.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() succeed,
    required TResult Function(Failure failure) failed,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succeed value) succeed,
    required TResult Function(_Failed value) failed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements ClassCancellationStatus {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$LoadingCopyWith<$Res> {
  factory _$LoadingCopyWith(_Loading value, $Res Function(_Loading) then) =
      __$LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadingCopyWithImpl<$Res>
    extends _$ClassCancellationStatusCopyWithImpl<$Res>
    implements _$LoadingCopyWith<$Res> {
  __$LoadingCopyWithImpl(_Loading _value, $Res Function(_Loading) _then)
      : super(_value, (v) => _then(v as _Loading));

  @override
  _Loading get _value => super._value as _Loading;
}

/// @nodoc

class _$_Loading implements _Loading {
  const _$_Loading();

  @override
  String toString() {
    return 'ClassCancellationStatus.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() succeed,
    required TResult Function(Failure failure) failed,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succeed value) succeed,
    required TResult Function(_Failed value) failed,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements ClassCancellationStatus {
  const factory _Loading() = _$_Loading;
}

/// @nodoc
abstract class _$SucceedCopyWith<$Res> {
  factory _$SucceedCopyWith(_Succeed value, $Res Function(_Succeed) then) =
      __$SucceedCopyWithImpl<$Res>;
}

/// @nodoc
class __$SucceedCopyWithImpl<$Res>
    extends _$ClassCancellationStatusCopyWithImpl<$Res>
    implements _$SucceedCopyWith<$Res> {
  __$SucceedCopyWithImpl(_Succeed _value, $Res Function(_Succeed) _then)
      : super(_value, (v) => _then(v as _Succeed));

  @override
  _Succeed get _value => super._value as _Succeed;
}

/// @nodoc

class _$_Succeed implements _Succeed {
  const _$_Succeed();

  @override
  String toString() {
    return 'ClassCancellationStatus.succeed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Succeed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() succeed,
    required TResult Function(Failure failure) failed,
  }) {
    return succeed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
  }) {
    return succeed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
    required TResult orElse(),
  }) {
    if (succeed != null) {
      return succeed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succeed value) succeed,
    required TResult Function(_Failed value) failed,
  }) {
    return succeed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
  }) {
    return succeed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
    required TResult orElse(),
  }) {
    if (succeed != null) {
      return succeed(this);
    }
    return orElse();
  }
}

abstract class _Succeed implements ClassCancellationStatus {
  const factory _Succeed() = _$_Succeed;
}

/// @nodoc
abstract class _$FailedCopyWith<$Res> {
  factory _$FailedCopyWith(_Failed value, $Res Function(_Failed) then) =
      __$FailedCopyWithImpl<$Res>;
  $Res call({Failure failure});

  $FailureCopyWith<$Res> get failure;
}

/// @nodoc
class __$FailedCopyWithImpl<$Res>
    extends _$ClassCancellationStatusCopyWithImpl<$Res>
    implements _$FailedCopyWith<$Res> {
  __$FailedCopyWithImpl(_Failed _value, $Res Function(_Failed) _then)
      : super(_value, (v) => _then(v as _Failed));

  @override
  _Failed get _value => super._value as _Failed;

  @override
  $Res call({
    Object? failure = freezed,
  }) {
    return _then(_Failed(
      failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }

  @override
  $FailureCopyWith<$Res> get failure {
    return $FailureCopyWith<$Res>(_value.failure, (value) {
      return _then(_value.copyWith(failure: value));
    });
  }
}

/// @nodoc

class _$_Failed implements _Failed {
  const _$_Failed(this.failure);

  @override
  final Failure failure;

  @override
  String toString() {
    return 'ClassCancellationStatus.failed(failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Failed &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  _$FailedCopyWith<_Failed> get copyWith =>
      __$FailedCopyWithImpl<_Failed>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() succeed,
    required TResult Function(Failure failure) failed,
  }) {
    return failed(failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
  }) {
    return failed?.call(failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? succeed,
    TResult Function(Failure failure)? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Succeed value) succeed,
    required TResult Function(_Failed value) failed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Succeed value)? succeed,
    TResult Function(_Failed value)? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class _Failed implements ClassCancellationStatus {
  const factory _Failed(Failure failure) = _$_Failed;

  Failure get failure;
  @JsonKey(ignore: true)
  _$FailedCopyWith<_Failed> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$UpcomingClassStateTearOff {
  const _$UpcomingClassStateTearOff();

  _UpcomingClassState call(
      {dynamic isLoading = false,
      int currentPage = 1,
      int limit = 20,
      Either<Failure, PaginationListDto<Appointment>> classOrFailure =
          const Right(PaginationListDto(list: [], totalItems: 0, limit: 20)),
      ClassCancellationStatus classCancellationStatus =
          const ClassCancellationStatus.initial(),
      Duration totalLearningTime = const Duration(),
      Appointment? nextClass,
      Appointment? selectedAppointment}) {
    return _UpcomingClassState(
      isLoading: isLoading,
      currentPage: currentPage,
      limit: limit,
      classOrFailure: classOrFailure,
      classCancellationStatus: classCancellationStatus,
      totalLearningTime: totalLearningTime,
      nextClass: nextClass,
      selectedAppointment: selectedAppointment,
    );
  }
}

/// @nodoc
const $UpcomingClassState = _$UpcomingClassStateTearOff();

/// @nodoc
mixin _$UpcomingClassState {
  dynamic get isLoading => throw _privateConstructorUsedError;
  int get currentPage => throw _privateConstructorUsedError;
  int get limit => throw _privateConstructorUsedError;
  Either<Failure, PaginationListDto<Appointment>> get classOrFailure =>
      throw _privateConstructorUsedError;
  ClassCancellationStatus get classCancellationStatus =>
      throw _privateConstructorUsedError;
  Duration get totalLearningTime => throw _privateConstructorUsedError;
  Appointment? get nextClass => throw _privateConstructorUsedError;
  Appointment? get selectedAppointment => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UpcomingClassStateCopyWith<UpcomingClassState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpcomingClassStateCopyWith<$Res> {
  factory $UpcomingClassStateCopyWith(
          UpcomingClassState value, $Res Function(UpcomingClassState) then) =
      _$UpcomingClassStateCopyWithImpl<$Res>;
  $Res call(
      {dynamic isLoading,
      int currentPage,
      int limit,
      Either<Failure, PaginationListDto<Appointment>> classOrFailure,
      ClassCancellationStatus classCancellationStatus,
      Duration totalLearningTime,
      Appointment? nextClass,
      Appointment? selectedAppointment});

  $ClassCancellationStatusCopyWith<$Res> get classCancellationStatus;
  $AppointmentCopyWith<$Res>? get nextClass;
  $AppointmentCopyWith<$Res>? get selectedAppointment;
}

/// @nodoc
class _$UpcomingClassStateCopyWithImpl<$Res>
    implements $UpcomingClassStateCopyWith<$Res> {
  _$UpcomingClassStateCopyWithImpl(this._value, this._then);

  final UpcomingClassState _value;
  // ignore: unused_field
  final $Res Function(UpcomingClassState) _then;

  @override
  $Res call({
    Object? isLoading = freezed,
    Object? currentPage = freezed,
    Object? limit = freezed,
    Object? classOrFailure = freezed,
    Object? classCancellationStatus = freezed,
    Object? totalLearningTime = freezed,
    Object? nextClass = freezed,
    Object? selectedAppointment = freezed,
  }) {
    return _then(_value.copyWith(
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as dynamic,
      currentPage: currentPage == freezed
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      classOrFailure: classOrFailure == freezed
          ? _value.classOrFailure
          : classOrFailure // ignore: cast_nullable_to_non_nullable
              as Either<Failure, PaginationListDto<Appointment>>,
      classCancellationStatus: classCancellationStatus == freezed
          ? _value.classCancellationStatus
          : classCancellationStatus // ignore: cast_nullable_to_non_nullable
              as ClassCancellationStatus,
      totalLearningTime: totalLearningTime == freezed
          ? _value.totalLearningTime
          : totalLearningTime // ignore: cast_nullable_to_non_nullable
              as Duration,
      nextClass: nextClass == freezed
          ? _value.nextClass
          : nextClass // ignore: cast_nullable_to_non_nullable
              as Appointment?,
      selectedAppointment: selectedAppointment == freezed
          ? _value.selectedAppointment
          : selectedAppointment // ignore: cast_nullable_to_non_nullable
              as Appointment?,
    ));
  }

  @override
  $ClassCancellationStatusCopyWith<$Res> get classCancellationStatus {
    return $ClassCancellationStatusCopyWith<$Res>(
        _value.classCancellationStatus, (value) {
      return _then(_value.copyWith(classCancellationStatus: value));
    });
  }

  @override
  $AppointmentCopyWith<$Res>? get nextClass {
    if (_value.nextClass == null) {
      return null;
    }

    return $AppointmentCopyWith<$Res>(_value.nextClass!, (value) {
      return _then(_value.copyWith(nextClass: value));
    });
  }

  @override
  $AppointmentCopyWith<$Res>? get selectedAppointment {
    if (_value.selectedAppointment == null) {
      return null;
    }

    return $AppointmentCopyWith<$Res>(_value.selectedAppointment!, (value) {
      return _then(_value.copyWith(selectedAppointment: value));
    });
  }
}

/// @nodoc
abstract class _$UpcomingClassStateCopyWith<$Res>
    implements $UpcomingClassStateCopyWith<$Res> {
  factory _$UpcomingClassStateCopyWith(
          _UpcomingClassState value, $Res Function(_UpcomingClassState) then) =
      __$UpcomingClassStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {dynamic isLoading,
      int currentPage,
      int limit,
      Either<Failure, PaginationListDto<Appointment>> classOrFailure,
      ClassCancellationStatus classCancellationStatus,
      Duration totalLearningTime,
      Appointment? nextClass,
      Appointment? selectedAppointment});

  @override
  $ClassCancellationStatusCopyWith<$Res> get classCancellationStatus;
  @override
  $AppointmentCopyWith<$Res>? get nextClass;
  @override
  $AppointmentCopyWith<$Res>? get selectedAppointment;
}

/// @nodoc
class __$UpcomingClassStateCopyWithImpl<$Res>
    extends _$UpcomingClassStateCopyWithImpl<$Res>
    implements _$UpcomingClassStateCopyWith<$Res> {
  __$UpcomingClassStateCopyWithImpl(
      _UpcomingClassState _value, $Res Function(_UpcomingClassState) _then)
      : super(_value, (v) => _then(v as _UpcomingClassState));

  @override
  _UpcomingClassState get _value => super._value as _UpcomingClassState;

  @override
  $Res call({
    Object? isLoading = freezed,
    Object? currentPage = freezed,
    Object? limit = freezed,
    Object? classOrFailure = freezed,
    Object? classCancellationStatus = freezed,
    Object? totalLearningTime = freezed,
    Object? nextClass = freezed,
    Object? selectedAppointment = freezed,
  }) {
    return _then(_UpcomingClassState(
      isLoading: isLoading == freezed ? _value.isLoading : isLoading,
      currentPage: currentPage == freezed
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      classOrFailure: classOrFailure == freezed
          ? _value.classOrFailure
          : classOrFailure // ignore: cast_nullable_to_non_nullable
              as Either<Failure, PaginationListDto<Appointment>>,
      classCancellationStatus: classCancellationStatus == freezed
          ? _value.classCancellationStatus
          : classCancellationStatus // ignore: cast_nullable_to_non_nullable
              as ClassCancellationStatus,
      totalLearningTime: totalLearningTime == freezed
          ? _value.totalLearningTime
          : totalLearningTime // ignore: cast_nullable_to_non_nullable
              as Duration,
      nextClass: nextClass == freezed
          ? _value.nextClass
          : nextClass // ignore: cast_nullable_to_non_nullable
              as Appointment?,
      selectedAppointment: selectedAppointment == freezed
          ? _value.selectedAppointment
          : selectedAppointment // ignore: cast_nullable_to_non_nullable
              as Appointment?,
    ));
  }
}

/// @nodoc

class _$_UpcomingClassState extends _UpcomingClassState {
  const _$_UpcomingClassState(
      {this.isLoading = false,
      this.currentPage = 1,
      this.limit = 20,
      this.classOrFailure =
          const Right(PaginationListDto(list: [], totalItems: 0, limit: 20)),
      this.classCancellationStatus = const ClassCancellationStatus.initial(),
      this.totalLearningTime = const Duration(),
      this.nextClass,
      this.selectedAppointment})
      : super._();

  @JsonKey()
  @override
  final dynamic isLoading;
  @JsonKey()
  @override
  final int currentPage;
  @JsonKey()
  @override
  final int limit;
  @JsonKey()
  @override
  final Either<Failure, PaginationListDto<Appointment>> classOrFailure;
  @JsonKey()
  @override
  final ClassCancellationStatus classCancellationStatus;
  @JsonKey()
  @override
  final Duration totalLearningTime;
  @override
  final Appointment? nextClass;
  @override
  final Appointment? selectedAppointment;

  @override
  String toString() {
    return 'UpcomingClassState(isLoading: $isLoading, currentPage: $currentPage, limit: $limit, classOrFailure: $classOrFailure, classCancellationStatus: $classCancellationStatus, totalLearningTime: $totalLearningTime, nextClass: $nextClass, selectedAppointment: $selectedAppointment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpcomingClassState &&
            const DeepCollectionEquality().equals(other.isLoading, isLoading) &&
            const DeepCollectionEquality()
                .equals(other.currentPage, currentPage) &&
            const DeepCollectionEquality().equals(other.limit, limit) &&
            const DeepCollectionEquality()
                .equals(other.classOrFailure, classOrFailure) &&
            const DeepCollectionEquality().equals(
                other.classCancellationStatus, classCancellationStatus) &&
            const DeepCollectionEquality()
                .equals(other.totalLearningTime, totalLearningTime) &&
            const DeepCollectionEquality().equals(other.nextClass, nextClass) &&
            const DeepCollectionEquality()
                .equals(other.selectedAppointment, selectedAppointment));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isLoading),
      const DeepCollectionEquality().hash(currentPage),
      const DeepCollectionEquality().hash(limit),
      const DeepCollectionEquality().hash(classOrFailure),
      const DeepCollectionEquality().hash(classCancellationStatus),
      const DeepCollectionEquality().hash(totalLearningTime),
      const DeepCollectionEquality().hash(nextClass),
      const DeepCollectionEquality().hash(selectedAppointment));

  @JsonKey(ignore: true)
  @override
  _$UpcomingClassStateCopyWith<_UpcomingClassState> get copyWith =>
      __$UpcomingClassStateCopyWithImpl<_UpcomingClassState>(this, _$identity);
}

abstract class _UpcomingClassState extends UpcomingClassState {
  const factory _UpcomingClassState(
      {dynamic isLoading,
      int currentPage,
      int limit,
      Either<Failure, PaginationListDto<Appointment>> classOrFailure,
      ClassCancellationStatus classCancellationStatus,
      Duration totalLearningTime,
      Appointment? nextClass,
      Appointment? selectedAppointment}) = _$_UpcomingClassState;
  const _UpcomingClassState._() : super._();

  @override
  dynamic get isLoading;
  @override
  int get currentPage;
  @override
  int get limit;
  @override
  Either<Failure, PaginationListDto<Appointment>> get classOrFailure;
  @override
  ClassCancellationStatus get classCancellationStatus;
  @override
  Duration get totalLearningTime;
  @override
  Appointment? get nextClass;
  @override
  Appointment? get selectedAppointment;
  @override
  @JsonKey(ignore: true)
  _$UpcomingClassStateCopyWith<_UpcomingClassState> get copyWith =>
      throw _privateConstructorUsedError;
}
